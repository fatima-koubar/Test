When I run this test file , I have an error that these two fields are not valid: epoch_timestamp, expires_at

describe('ApplePayApi', () => {
  let service: ApplePayApi;
  let apiCallerServiceSpy: jasmine.SpyObj<ApiCallerService>;

  const mockMerchantVerificationDto = {
    display_name: 'Société COUSSIFL pour le TPE FCOMULT',
    domain_name: 'rqt-p.monetico-services.com',
    epoch_timestamp: new Date(),
    expires_at: new Date(),
    merchant_identifier: '984D8176',
    merchant_session_identifier: 'SSH44A4C68',
    nonce: 'c39ccc91',
    operational_analytics_identifier: 'Société COUSSIFL pour le TPE FCOMULT',
    psp_id: '984D817638FD96948C059FE51',
    retries: 0,
    signature: '308006092a864886f70d01',
  };

  const mockMerchantValidationRequest = {
    initiative_context: 'context',
    validation_url: 'https://validation_url.com/',
    display_name: 'name',
    merchant_identifier: '984D8176',
  };

  beforeEach(() => {
    apiCallerServiceSpy = jasmine.createSpyObj<ApiCallerService>('ApiCallerService', [
      'get',
      'put',
      'post',
    ]);

    TestBed.configureTestingModule({
      providers: [
        ApplePayApi,
        { provide: ApiCallerService, useValue: apiCallerServiceSpy },
      ],
    });

    service = TestBed.inject(ApplePayApi);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  describe('merchantVerification', () => {
    it('should POST merchant verification request and validate response', () => {
      const request = mockMerchantValidationRequest;
      const response = mockMerchantVerificationDto;

      apiCallerServiceSpy.post.and.returnValue(of(response));

      service.merchantVerification(request).subscribe((result) => {
        expect(result).toBe(response);
      });

      expect(apiCallerServiceSpy.post).toHaveBeenCalledWith(
        `https://${window.location.hostname}/applepay/merchantverification`,
        JSON.stringify(request),
      );
    });
  });
});



service file 

const merchantverificationPath = '/applepay/merchantverification';

@Injectable({
  providedIn: 'root',
})
export class ApplePayApi {
  private readonly _apiCallerService = inject(ApiCallerService);

  public merchantVerification(
    merchantValidationRequest: MerchantValidationRequest,
  ): Observable<MerchantVerificationDTO> | never {
    return this._apiCallerService
      .post(
        'https://' + window.location.hostname + merchantverificationPath,
        JSON.stringify(merchantValidationRequest),
      )
      .pipe(
        map((raw) => {
          validateMerchantVerificationDTO(raw);
          return raw;
        }),
      );
  }
}

DTO file

export type MerchantVerificationDTO = {
  display_name: string;
  domain_name: string;
  epoch_timestamp: Date;
  expires_at: Date;
  merchant_identifier: string;
  merchant_session_identifier: string;
  nonce: string;
  operational_analytics_identifier: string;
  psp_id: string;
  retries: number;
  signature: string;
};


validator file 

export function validateMerchantVerificationDTO(
  data: Record<string, unknown>,
): asserts data is MerchantVerificationDTO {
  if (!MERCHANT_VERIFICATION_SCHEMA.validate(data)) {
    throw new InvalidFieldsError(MERCHANT_VERIFICATION_SCHEMA.getValidationErrors(data), data);
  }
}

schema file 

export const MERCHANT_VERIFICATION_SCHEMA: Schema = objectType({
  display_name: stringType(),
  domain_name: stringType(),
  epoch_timestamp: numberType(),
  expires_at: numberType(),
  merchant_identifier: stringType(),
  merchant_session_identifier: stringType(),
  nonce: stringType(),
  operational_analytics_identifier: stringType(),
  psp_id: stringType(),
  retries: numberType(),
  signature: stringType(),
});

