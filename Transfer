
genere un unit test pour ce code angular avec jasmine

@Injectable({
  providedIn: 'root',
})
export class ApplePayService {
  private _callbackError: (() => void) | undefined;
  private _callbackSubmit: (() => void) | undefined;

  private readonly _applePayApi = inject(ApplePayApi);
  private readonly _toastrService = inject(PcToastrService);

  setSubmitEvent(callbackSubmit: () => void): void {
    this._callbackSubmit = callbackSubmit;
  }

  setErrorEvent(callbackError: () => void): void {
    this._callbackError = callbackError;
  }

  setCollectionSessionHref(paymentMeanHref: string): void {
    this._applePayApi.setCollectionSessionHref(paymentMeanHref);
  }

  async getCollectionSessionData(): Promise<{
    brandList: string[];
    testCards: TestCard[];
    countryCode: string;
    merchantName: string;
    amount: string;
    payload: ApplePaySessionPayload;
  }> {
    try {
      const res = await firstValueFrom(this._applePayApi.getCollectionSessionData());

      const adjustedValue = res.amount.value * Math.pow(10, res.amount.exponent);
      const formattedValue = adjustedValue.toFixed(2);

      return {
        brandList: res.display_data['accepted_schemes'].map((scheme: any) =>
          scheme.brand.toLowerCase(),
        ),
        testCards: res.display_data['test_cards'],
        countryCode: res.country_code,
        merchantName: res.merchant_name,
        amount: formattedValue,
        payload: {
          collection_session_id: res.id,
          merchant_identifier: res.merchant_identifier,
          merchant_name: res.merchant_name,
          domain: res.domain,
        },
      };
    } catch {
      this._toastrService.notify('_SHARED.ERRORS.TECHNICAL_PROBLEM');
      throw new Error('APPLE_PAY_DATA_ERROR');
    }
  }

  async putToken(token: string): Promise<void> {
    try {
      await firstValueFrom(this._applePayApi.putToken(token));
      if (this._callbackSubmit) {
        this._callbackSubmit();
      }
    } catch (error) {
      this.handlePutTokenError(error);
      if (this._callbackError) {
        this._callbackError();
      }
    }
  }

  private handlePutTokenError(error: unknown): void {
    if (!(error instanceof APIError)) {
      this.notifyTechnicalError();
      return;
    }

    const errorType = error.error['error'].type;

    switch (errorType) {
      case CARD_ERRORS.CARD_NOT_ACCEPTED:
        this._toastrService.notify('PAYMENT_MEANS.APPLE_PAY.ERRORS.CARD_NOT_ACCEPTED');
        break;
      case CARD_ERRORS.EXPIRATION_DATE_NOT_ACCEPTED:
        this._toastrService.notify('PAYMENT_MEANS.APPLE_PAY.ERRORS.RESTRICTION_EXPIRATION_DATE', {
          months: error.error['restriction_delay'],
        });
        break;
      case CARD_ERRORS.EXPIRATION_DATE_EXPIRED:
        this._toastrService.notify('PAYMENT_MEANS.APPLE_PAY.ERRORS.EXPIRED');
        break;
      case CARD_ERRORS.INVALID_CARD:
        this._toastrService.notify('PAYMENT_MEANS.APPLE_PAY.ERRORS.INVALID');
        break;
      default:
        this.notifyTechnicalError();
        break;
    }
  }

  private notifyTechnicalError(): void {
    this._toastrService.notify('_SHARED.ERRORS.TECHNICAL_PROBLEM');
  }
}

