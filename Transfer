fichier .spec.ts: 
describe('ApplePayComponent', () => {
  let component: ApplePayComponent;
  let fixture: ComponentFixture<ApplePayComponent>;

  let applePayAdapterServiceSpy: jasmine.SpyObj<ApplePayAdapterService>;
  let applePayServiceSpy: jasmine.SpyObj<ApplePayService>;
  let applePayFlowServiceSpy: jasmine.SpyObj<ApplePayFlowService>;
  let spinnerServiceSpy: jasmine.SpyObj<SpinnerService>;
  let paymentSessionStoreSpy: jasmine.SpyObj<InstanceType<typeof PaymentSessionStore>>;

  beforeEach(async () => {
    applePayAdapterServiceSpy = jasmine.createSpyObj<ApplePayAdapterService>(
      'ApplePayAdapterService',
      ['canApplePayPayment'],
    );

    TestBed.configureTestingModule({
      imports: [ApplePayComponent],
      providers: [
        { provide: ApplePayAdapterService, useValue: applePayAdapterServiceSpy },
        importProvidersFrom([TranslateModule.forRoot()]),
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(ApplePayComponent);
    component = fixture.componentInstance;

    fixture.componentRef.setInput('paymentMeanHref', 'https://monetico-services.com/c9da4fcc8');
    fixture.componentRef.setInput('amount', { currency: 'EUR', exponent: 100, value: 100 } as any);
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should show payButton button when Apple Pay is NOT available', () => {
    applePayAdapterServiceSpy.canApplePayPayment.and.returnValue(false);

    fixture.detectChanges();

    const applePayButton = fixture.nativeElement.querySelector('pc-apple-pay-button');
    const payButton = fixture.nativeElement.querySelector('button.pay-button');

    expect(applePayButton).toBeFalsy();
    expect(payButton).toBeTruthy();
  });

});

fichier amountPipe:
@Pipe({
  name: 'amount',
  standalone: true,
})
export class AmountPipe implements PipeTransform {
  _translateService = inject(TranslateService);

  currencyPipe: CurrencyPipe = new CurrencyPipe(this.locale);

  private get locale(): string {
    const currentLang = this._translateService.getCurrentLang();
    const fallbackLang = this._translateService.getFallbackLang();

    if (Object.values(LANGUAGES).includes(currentLang as LanguageKey)) {
      return currentLang;
    }

    return typeof fallbackLang === 'string' ? currentLang || fallbackLang : currentLang;
  }

  transform(amount: Amount): string {
    let value = amount.value;
    if (amount.exponent) {
      value = value * Math.pow(10, amount.exponent);
    }

    const result =
      this.currencyPipe.transform(value, amount.currency, 'symbol', '1.2-2') ||
      amount.value + amount.currency;
    return result;
  }
}

