apple-pay-session.builder.ts
import { ApplePaySessionPayload } from '../../../../models/apple-pay-session-payload.model';
import { MerchantSession } from '../../../../models/merchant-session.model';
import { MerchantValidationRequest } from '../../../../models/merchant-validation-request.model';
import { ApplePayPaymentRequest } from './apple-pay-request.builder';

export class ApplePaySessionBuilder {
  private session: any;
  private applePaySessionPayload: ApplePaySessionPayload;

  constructor(request: ApplePayPaymentRequest, applePaySessionPayload: ApplePaySessionPayload) {
    this.session = new (window as any).ApplePaySession(3, request);
    this.applePaySessionPayload = applePaySessionPayload;
  }

  public withValidationMerchantEventHandler(
    callback: (merchantValidationRequest: MerchantValidationRequest) => Promise<any>,
  ) {
    this.session.onvalidatemerchant = async (event: any) => {
      try {
        let merchantValidationRequest: MerchantValidationRequest = {
          merchant_identifier: this.applePaySessionPayload.merchant_identifier,
          initiative_context: this.applePaySessionPayload.domain ?? window.location.hostname,
          validation_url: event.validationURL,
          display_name: this.applePaySessionPayload.merchant_name,
          collection_session_id: this.applePaySessionPayload.collection_session_id,
        };

        const validationData: MerchantSession = await callback(merchantValidationRequest);

        this.session.completeMerchantValidation(validationData);
      } catch (error) {
        throw new Error((error as Error).message);
      }
    };

    return this;
  }
  public withCancelEventHandler(callback: (() => void) | undefined): ApplePaySessionBuilder {
    if (callback) this.session.oncancel = callback;
    return this;
  }
  public withPaymentAuthorizedEventHandler(callback: (token: string) => Promise<any>) {
    this.session.onpaymentauthorized = async (event: any) => {
      const result = {
        status: (window as any).ApplePaySession.STATUS_SUCCESS,
      };

      event.payment.token.paymentMethod.network =
        event.payment.token.paymentMethod.network.toLowerCase();

      this.session.completePayment(result);

      callback(btoa(JSON.stringify(event.payment.token)));
    };

    return this;
  }

  public build() {
    return this.session;
  }
}

apple-pay-request.builder.ts
export class ApplePayRequestBuilder {
    private countryCode!: string;
    private currencyCode!: string;
    private merchantCapabilities!: string[];
    private supportedNetworks!: string[];
    private total!: { label: string, type: string, amount: string };

    public setCountryCode(countryCode: string): ApplePayRequestBuilder {
        this.countryCode = countryCode;
        return this;
    }

    public setCurrencyCode(currencyCode: string): ApplePayRequestBuilder {
        this.currencyCode = currencyCode;
        return this;
    }

    public setMerchantCapabilities(merchantCapabilities: string[]): ApplePayRequestBuilder {
        this.merchantCapabilities = merchantCapabilities;
        return this;
    }

    public setSupportedNetworks(supportedNetworks: string[]): ApplePayRequestBuilder {
        this.supportedNetworks = supportedNetworks;
        return this;
    }

    public setTotal(total: { label: string, type: string, amount: string }): ApplePayRequestBuilder {
        this.total = total;
        return this;
    }

    public build(): ApplePayPaymentRequest {
        return new ApplePayPaymentRequest(
            this.countryCode,
            this.currencyCode,
            this.merchantCapabilities,
            this.supportedNetworks,
            this.total
        );
    }
}

export class ApplePayPaymentRequest {
    constructor(
        public countryCode: string,
        public currencyCode: string,
        public merchantCapabilities: string[],
        public supportedNetworks: string[],
        public total: { label: string, type: string, amount: string }
    ) {}
}
