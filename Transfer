
genere un unit test pour ce code angular avec jasmine

@Injectable({
  providedIn: 'root',
})
export class ApplePayTestCardsService {
  readonly sortedTestCards: WritableSignal<TestCard[]> = signal<Array<TestCard>>([]);
  readonly testCardsByScheme: WritableSignal<Partial<Record<SchemeType, Array<TestCard>>>> = signal<
    Partial<Record<SchemeType, Array<TestCard>>>
  >({});
  readonly arrayPaiementOptions: WritableSignal<ArrayOption[]> = signal<ArrayOption[]>([]);

  private readonly _translateService = inject(TranslateService);
  private readonly _applePayFlowService = inject(ApplePayFlowService);

  getSortedCards(): TestCard[] {
    return this.sortedTestCards();
  }

  setSortedCards(): void {
    this.sortedTestCards.set(
      [...this._applePayFlowService.testCards()].sort((a, b) => a.scheme.localeCompare(b.scheme)),
    );
  }

  setTestCardsByScheme(): void {
    this.testCardsByScheme.set(
      this.sortedTestCards().reduce(
        (acc: Partial<Record<SchemeType, Array<TestCard>>>, testCard) =>
          Object.assign(acc, {
            [testCard.scheme]: (acc[testCard.scheme] ?? []).concat(testCard),
          }),
        {},
      ),
    );
  }

  getArrayPaiementOptions(): ArrayOption[] {
    return this.arrayPaiementOptions();
  }

  setArrayPaiementOptions(): void {
    let index = 0;
    this.arrayPaiementOptions.set(
      Object.entries(this.testCardsByScheme()).map<ArrayOption>((entry) => ({
        optionGroupName: entry[0],
        options: entry[1].reduce((options: Array<Option>, testCard) => {
          const scenarioStatusLabel = this.getScenarioStatusLabel(testCard);
          const threeDSLabel = this.getThreeDSLabel(testCard);
          if (!testCard.authentication_scenario) {
            options.push(
              new Option(`sc-${index}`, `${testCard.scheme} - ${scenarioStatusLabel}`, ''),
            );
            return options;
          }

          options.push(
            new Option(
              `sc-${index}`,
              `${testCard.scheme} - ${scenarioStatusLabel} - ${threeDSLabel}`,
              '',
            ),
          );
          index++;
          return options;
        }, []),
      })),
    );
  }

  private getScenarioStatusLabel(testCard: TestCard): string {
    return testCard.authorization_scenario === AuthorizationScenario.ACCEPTED
      ? this._translateService.instant('PAYMENT_MEANS.CARD.TEST_CARD.PAYMENT_STATUS.ACCEPTED')
      : this._translateService.instant('PAYMENT_MEANS.CARD.TEST_CARD.PAYMENT_STATUS.REFUSED');
  }

  private getThreeDSLabel(testCard: TestCard): string {
    return testCard.authentication_scenario &&
      testCard.authentication_scenario.result === AuthenticationResult.NOT_ENROLLED
      ? this._translateService.instant('PAYMENT_MEANS.CARD.TEST_CARD.3DS_STATUS.NOT_SUPPORTED')
      : this._translateService.instant('PAYMENT_MEANS.CARD.TEST_CARD.3DS_STATUS.SUPPORTED');
  }
}


import { TestBed } from '@angular/core/testing';
import { ApplePayTestCardsService } from './apple-pay-test-cards.service';
import { TranslateService } from '@ngx-translate/core';
import { ApplePayFlowService } from './apple-pay-flow.service';
import { AuthorizationScenario, AuthenticationResult, SchemeType } from '../models/enums';
import { TestCard } from '../models/test-card.model';

describe('ApplePayTestCardsService', () => {
  let service: ApplePayTestCardsService;
  let translateServiceSpy: jasmine.SpyObj<TranslateService>;
  let applePayFlowServiceSpy: jasmine.SpyObj<ApplePayFlowService>;

  const mockTestCards: TestCard[] = [
    {
      scheme: SchemeType.MASTERCARD,
      authorization_scenario: AuthorizationScenario.ACCEPTED,
      authentication_scenario: {
        result: AuthenticationResult.NOT_ENROLLED,
      },
    } as TestCard,
    {
      scheme: SchemeType.VISA,
      authorization_scenario: AuthorizationScenario.REFUSED,
    } as TestCard,
  ];

  beforeEach(() => {
    translateServiceSpy = jasmine.createSpyObj('TranslateService', ['instant']);
    applePayFlowServiceSpy = jasmine.createSpyObj(
      'ApplePayFlowService',
      ['testCards'],
    );

    translateServiceSpy.instant.and.callFake((key: string) => key);
    applePayFlowServiceSpy.testCards.and.returnValue(mockTestCards);

    TestBed.configureTestingModule({
      providers: [
        ApplePayTestCardsService,
        { provide: TranslateService, useValue: translateServiceSpy },
        { provide: ApplePayFlowService, useValue: applePayFlowServiceSpy },
      ],
    });

    service = TestBed.inject(ApplePayTestCardsService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  describe('setSortedCards', () => {
    it('should sort test cards by scheme', () => {
      service.setSortedCards();

      const result = service.getSortedCards();
      expect(result.length).toBe(2);
      expect(result[0].scheme).toBe(SchemeType.MASTERCARD);
      expect(result[1].scheme).toBe(SchemeType.VISA);
    });
  });

  describe('setTestCardsByScheme', () => {
    it('should group cards by scheme', () => {
      service.setSortedCards();
      service.setTestCardsByScheme();

      const result = service.testCardsByScheme();
      expect(result[SchemeType.VISA]?.length).toBe(1);
      expect(result[SchemeType.MASTERCARD]?.length).toBe(1);
    });
  });

  describe('setArrayPaiementOptions', () => {
    it('should build payment options array', () => {
      service.setSortedCards();
      service.setTestCardsByScheme();
      service.setArrayPaiementOptions();

      const result = service.getArrayPaiementOptions();
      expect(result.length).toBe(2);

      const visaGroup = result.find(r => r.optionGroupName === SchemeType.VISA);
      expect(visaGroup).toBeDefined();
      expect(visaGroup!.options.length).toBe(1);
    });

    it('should call translate service for labels', () => {
      service.setSortedCards();
      service.setTestCardsByScheme();
      service.setArrayPaiementOptions();

      expect(translateServiceSpy.instant).toHaveBeenCalled();
    });
  });
});

