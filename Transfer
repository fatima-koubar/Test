template file:
<div class="mp_acc_paymtmean_panel ei_relative applepay_container">
  <div class="ei_flex ei_flex_justcenter">
    @if (canApplePayPayment()) {
      <pc-apple-pay-button (handleClick)="handleClick()" class="mt-4"></pc-apple-pay-button>
    } @else {
      <button class="pay-button mp_btn mp_btn_pay cpc ei_flex_justcenter" (click)="handleClick()">
        <span
          translate
          [translateParams]="{
            amount: amount() | amount
          }"
        >
          _SHARED.ACTIONS.PAY
        </span>
      </button>
    }
  </div>
</div>
@if (showCustomOverlay()) {
  <div id="pc-overlay"></div>
}

apple-pay.component.ts

const MODAL_PAGE_OVERLAY_SELECTOR = 'div.modal.modal-crossfade.modal-page-overlay.modal-open';
const APPLEPAY_MODAL_SELECTOR = 'apple-pay-modal';
const APPLE_PAY_POPIN = '/apple-pay/popin';

@Component({
  selector: 'pc-apple-pay',
  templateUrl: './apple-pay.component.html',
  imports: [AmountPipe, ApplePayButtonComponent, TranslateDirective],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  standalone: true,
})
export class ApplePayComponent implements OnInit {
  paymentMeanHref: InputSignal<string> = input.required<string>();
  amount: InputSignal<Amount> = input.required<Amount>();
  submitEvent: OutputEmitterRef<PaymentMeanType> = output<PaymentMeanType>();
  showCustomOverlay: WritableSignal<boolean> = signal<boolean>(false);
  canApplePayPayment: Signal<boolean> = computed(() =>
    this._applePayAdapterService.canApplePayPayment(),
  );

  private readonly _spinnerService = inject(SpinnerService);
  private readonly _applePayAdapterService = inject(ApplePayAdapterService);
  private readonly _document = inject(DOCUMENT);
  private readonly _integrationType = inject(PAYMENT_SESSION_CONTEXT);
  private readonly _paymentSessionStore = inject(PaymentSessionStore);
  private readonly _applePayService = inject(ApplePayService);
  private readonly _applePayFlowService = inject(ApplePayFlowService);

  async ngOnInit(): Promise<void> {
    this._applePayService.setCollectionSessionHref(this.paymentMeanHref());
    await this._applePayFlowService.init();
    this._applePayFlowService.setCloseEvent(() => {
      this.showCustomOverlay.set(false);
    });

    this._applePayService.setErrorEvent(() => {
      this._spinnerService.removeComponent();
      this.createSession();
    });

    this._applePayService.setSubmitEvent(() => {
      this.submitEvent.emit(PAYMENT_MEAN_TYPES.APPLEPAY);
    });
  }

  handleClick(): void {
    if (this._integrationType == INTEGRATION_TYPES.PAYMENT_COMPONENT) {
      window.parent.postMessage(
        { action: 'create', url: window.location.href + APPLE_PAY_POPIN },
        '*',
      );
    } else {
      this.createSession();
      const overlay = this._document
        .querySelector(APPLEPAY_MODAL_SELECTOR)
        ?.shadowRoot?.querySelector(MODAL_PAGE_OVERLAY_SELECTOR) as HTMLElement;
      overlay?.style.setProperty('background', 'rgb(0 0 0 / 0%)');
    }
  }

  private createSession(): void {
    if (!this._paymentSessionStore.sandbox()) {
      this.showCustomOverlay.set(true);
    }
    this._applePayFlowService.startTransaction();
  }
}

import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ApplePayComponent } from './apple-pay.component';
import { DOCUMENT } from '@angular/common';
import { signal } from '@angular/core';

import {
  ApplePayAdapterService,
  ApplePayService,
  ApplePayFlowService,
  SpinnerService,
  PaymentSessionStore,
} from '../services'; // adjust paths

import {
  INTEGRATION_TYPES,
  PAYMENT_MEAN_TYPES,
  PAYMENT_SESSION_CONTEXT,
} from '../constants';

describe('ApplePayComponent', () => {
  let component: ApplePayComponent;
  let fixture: ComponentFixture<ApplePayComponent>;

  let applePayAdapterService: jasmine.SpyObj<ApplePayAdapterService>;
  let applePayService: jasmine.SpyObj<ApplePayService>;
  let applePayFlowService: jasmine.SpyObj<ApplePayFlowService>;
  let spinnerService: jasmine.SpyObj<SpinnerService>;
  let paymentSessionStore: jasmine.SpyObj<PaymentSessionStore>;

  beforeEach(async () => {
    applePayAdapterService = jasmine.createSpyObj('ApplePayAdapterService', [
      'canApplePayPayment',
    ]);

    applePayService = jasmine.createSpyObj('ApplePayService', [
      'setCollectionSessionHref',
      'setErrorEvent',
      'setSubmitEvent',
    ]);

    applePayFlowService = jasmine.createSpyObj('ApplePayFlowService', [
      'init',
      'startTransaction',
      'setCloseEvent',
    ]);
    applePayFlowService.init.and.resolveTo();

    spinnerService = jasmine.createSpyObj('SpinnerService', ['removeComponent']);

    paymentSessionStore = jasmine.createSpyObj('PaymentSessionStore', [
      'sandbox',
    ]);
    paymentSessionStore.sandbox.and.returnValue(false);

    await TestBed.configureTestingModule({
      imports: [ApplePayComponent],
      providers: [
        { provide: ApplePayAdapterService, useValue: applePayAdapterService },
        { provide: ApplePayService, useValue: applePayService },
        { provide: ApplePayFlowService, useValue: applePayFlowService },
        { provide: SpinnerService, useValue: spinnerService },
        { provide: PaymentSessionStore, useValue: paymentSessionStore },
        { provide: PAYMENT_SESSION_CONTEXT, useValue: INTEGRATION_TYPES.EMBEDDED },
        { provide: DOCUMENT, useValue: document },
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(ApplePayComponent);
    component = fixture.componentInstance;

    // required input signals
    component.paymentMeanHref = signal('http://test-url');
    component.amount = signal({ value: 100, currency: 'EUR' } as any);
  });

  /* -------------------- INIT -------------------- */

  it('should initialize Apple Pay flow on init', async () => {
    await component.ngOnInit();

    expect(applePayService.setCollectionSessionHref).toHaveBeenCalledWith(
      'http://test-url',
    );
    expect(applePayFlowService.init).toHaveBeenCalled();
    expect(applePayFlowService.setCloseEvent).toHaveBeenCalled();
    expect(applePayService.setErrorEvent).toHaveBeenCalled();
    expect(applePayService.setSubmitEvent).toHaveBeenCalled();
  });

  /* -------------------- TEMPLATE -------------------- */

  it('should show Apple Pay button when Apple Pay is available', () => {
    applePayAdapterService.canApplePayPayment.and.returnValue(true);

    fixture.detectChanges();

    const applePayButton =
      fixture.nativeElement.querySelector('pc-apple-pay-button');
    const fallbackButton =
      fixture.nativeElement.querySelector('button.pay-button');

    expect(applePayButton).toBeTruthy();
    expect(fallbackButton).toBeFalsy();
  });

  it('should show fallback button when Apple Pay is NOT available', () => {
    applePayAdapterService.canApplePayPayment.and.returnValue(false);

    fixture.detectChanges();

    const applePayButton =
      fixture.nativeElement.querySelector('pc-apple-pay-button');
    const fallbackButton =
      fixture.nativeElement.querySelector('button.pay-button');

    expect(applePayButton).toBeFalsy();
    expect(fallbackButton).toBeTruthy();
  });

  /* -------------------- CLICK HANDLING -------------------- */

  it('should start Apple Pay session when handleClick is called', () => {
    component.handleClick();

    expect(component.showCustomOverlay()).toBeTrue();
    expect(applePayFlowService.startTransaction).toHaveBeenCalled();
  });

  it('should NOT show overlay when sandbox mode is enabled', () => {
    paymentSessionStore.sandbox.and.returnValue(true);

    component.handleClick();

    expect(component.showCustomOverlay()).toBeFalse();
    expect(applePayFlowService.startTransaction).toHaveBeenCalled();
  });

  /* -------------------- PAYMENT COMPONENT MODE -------------------- */

  it('should post message when integration type is PAYMENT_COMPONENT', () => {
    spyOn(window.parent, 'postMessage');

    TestBed.overrideProvider(PAYMENT_SESSION_CONTEXT, {
      useValue: INTEGRATION_TYPES.PAYMENT_COMPONENT,
    });

    fixture = TestBed.createComponent(ApplePayComponent);
    component = fixture.componentInstance;
    component.paymentMeanHref = signal('url');
    component.amount = signal({} as any);

    component.handleClick();

    expect(window.parent.postMessage).toHaveBeenCalled();
  });

  /* -------------------- SUBMIT EVENT -------------------- */

  it('should emit submit event when Apple Pay submit is triggered', async () => {
    spyOn(component.submitEvent, 'emit');

    await component.ngOnInit();

    // grab submit callback
    const submitCallback =
      applePayService.setSubmitEvent.calls.mostRecent().args[0];

    submitCallback();

    expect(component.submitEvent.emit).toHaveBeenCalledWith(
      PAYMENT_MEAN_TYPES.APPLEPAY,
    );
  });
});


