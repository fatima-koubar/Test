import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ApplePayComponent } from './apple-pay.component';
import { DOCUMENT } from '@angular/common';
import { signal } from '@angular/core';

import {
  ApplePayAdapterService,
  ApplePayService,
  ApplePayFlowService,
  SpinnerService,
  PaymentSessionStore,
} from '../services'; // adjust paths

import {
  INTEGRATION_TYPES,
  PAYMENT_MEAN_TYPES,
  PAYMENT_SESSION_CONTEXT,
} from '../constants';

describe('ApplePayComponent', () => {
  let component: ApplePayComponent;
  let fixture: ComponentFixture<ApplePayComponent>;

  let applePayAdapterService: jasmine.SpyObj<ApplePayAdapterService>;
  let applePayService: jasmine.SpyObj<ApplePayService>;
  let applePayFlowService: jasmine.SpyObj<ApplePayFlowService>;
  let spinnerService: jasmine.SpyObj<SpinnerService>;
  let paymentSessionStore: jasmine.SpyObj<PaymentSessionStore>;

  beforeEach(async () => {
    applePayAdapterService = jasmine.createSpyObj('ApplePayAdapterService', [
      'canApplePayPayment',
    ]);

    applePayService = jasmine.createSpyObj('ApplePayService', [
      'setCollectionSessionHref',
      'setErrorEvent',
      'setSubmitEvent',
    ]);

    applePayFlowService = jasmine.createSpyObj('ApplePayFlowService', [
      'init',
      'startTransaction',
      'setCloseEvent',
    ]);
    applePayFlowService.init.and.resolveTo();

    spinnerService = jasmine.createSpyObj('SpinnerService', ['removeComponent']);

    paymentSessionStore = jasmine.createSpyObj('PaymentSessionStore', [
      'sandbox',
    ]);
    paymentSessionStore.sandbox.and.returnValue(false);

    await TestBed.configureTestingModule({
      imports: [ApplePayComponent],
      providers: [
        { provide: ApplePayAdapterService, useValue: applePayAdapterService },
        { provide: ApplePayService, useValue: applePayService },
        { provide: ApplePayFlowService, useValue: applePayFlowService },
        { provide: SpinnerService, useValue: spinnerService },
        { provide: PaymentSessionStore, useValue: paymentSessionStore },
        { provide: PAYMENT_SESSION_CONTEXT, useValue: INTEGRATION_TYPES.EMBEDDED },
        { provide: DOCUMENT, useValue: document },
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(ApplePayComponent);
    component = fixture.componentInstance;

    // required input signals
    component.paymentMeanHref = signal('http://test-url');
    component.amount = signal({ value: 100, currency: 'EUR' } as any);
  });

  /* -------------------- INIT -------------------- */

  it('should initialize Apple Pay flow on init', async () => {
    await component.ngOnInit();

    expect(applePayService.setCollectionSessionHref).toHaveBeenCalledWith(
      'http://test-url',
    );
    expect(applePayFlowService.init).toHaveBeenCalled();
    expect(applePayFlowService.setCloseEvent).toHaveBeenCalled();
    expect(applePayService.setErrorEvent).toHaveBeenCalled();
    expect(applePayService.setSubmitEvent).toHaveBeenCalled();
  });

  /* -------------------- TEMPLATE -------------------- */

  it('should show Apple Pay button when Apple Pay is available', () => {
    applePayAdapterService.canApplePayPayment.and.returnValue(true);

    fixture.detectChanges();

    const applePayButton =
      fixture.nativeElement.querySelector('pc-apple-pay-button');
    const fallbackButton =
      fixture.nativeElement.querySelector('button.pay-button');

    expect(applePayButton).toBeTruthy();
    expect(fallbackButton).toBeFalsy();
  });

  it('should show fallback button when Apple Pay is NOT available', () => {
    applePayAdapterService.canApplePayPayment.and.returnValue(false);

    fixture.detectChanges();

    const applePayButton =
      fixture.nativeElement.querySelector('pc-apple-pay-button');
    const fallbackButton =
      fixture.nativeElement.querySelector('button.pay-button');

    expect(applePayButton).toBeFalsy();
    expect(fallbackButton).toBeTruthy();
  });

  /* -------------------- CLICK HANDLING -------------------- */

  it('should start Apple Pay session when handleClick is called', () => {
    component.handleClick();

    expect(component.showCustomOverlay()).toBeTrue();
    expect(applePayFlowService.startTransaction).toHaveBeenCalled();
  });

  it('should NOT show overlay when sandbox mode is enabled', () => {
    paymentSessionStore.sandbox.and.returnValue(true);

    component.handleClick();

    expect(component.showCustomOverlay()).toBeFalse();
    expect(applePayFlowService.startTransaction).toHaveBeenCalled();
  });

  /* -------------------- PAYMENT COMPONENT MODE -------------------- */

  it('should post message when integration type is PAYMENT_COMPONENT', () => {
    spyOn(window.parent, 'postMessage');

    TestBed.overrideProvider(PAYMENT_SESSION_CONTEXT, {
      useValue: INTEGRATION_TYPES.PAYMENT_COMPONENT,
    });

    fixture = TestBed.createComponent(ApplePayComponent);
    component = fixture.componentInstance;
    component.paymentMeanHref = signal('url');
    component.amount = signal({} as any);

    component.handleClick();

    expect(window.parent.postMessage).toHaveBeenCalled();
  });

  /* -------------------- SUBMIT EVENT -------------------- */

  it('should emit submit event when Apple Pay submit is triggered', async () => {
    spyOn(component.submitEvent, 'emit');

    await component.ngOnInit();

    // grab submit callback
    const submitCallback =
      applePayService.setSubmitEvent.calls.mostRecent().args[0];

    submitCallback();

    expect(component.submitEvent.emit).toHaveBeenCalledWith(
      PAYMENT_MEAN_TYPES.APPLEPAY,
    );
  });
});


