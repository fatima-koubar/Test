import { inject, Injectable, ViewContainerRef } from '@angular/core';
import { ApplePayRequestBuilder } from './builders/apple-pay-request.builder';
import { ApplePayApi } from '../../../api/apple-pay.api';
import { firstValueFrom } from 'rxjs';
import { PcToastrService } from '../../../../core';
import { ApplePaySessionBuilder } from './builders/apple-pay-session.builder';
import { MerchantSession } from '../../../models/merchant-session.model';
import { ApplePaySessionPayload } from '../../../models/apple-pay-session-payload.model';
import { ApplePayService } from '../../../services/apple-pay.service';

@Injectable({
  providedIn: 'root',
})
export class ApplePaySessionBuilderService {
  private readonly _applePayApi = inject(ApplePayApi);
  private readonly _toastrService = inject(PcToastrService);
  private readonly _applePayService = inject(ApplePayService);

  createSession(params: {
    countryCode: string;
    brandList: string[];
    merchantName: string;
    amount: string;
    payload: ApplePaySessionPayload;
    container: ViewContainerRef;
    onCancel?: () => void;
  }) {
    const request = new ApplePayRequestBuilder()
      .setCountryCode(params.countryCode)
      .setCurrencyCode('EUR')
      .setMerchantCapabilities(['supports3DS'])
      .setSupportedNetworks(params.brandList)
      .setTotal({
        label: params.merchantName,
        type: 'final',
        amount: params.amount,
      })
      .build();

    return new ApplePaySessionBuilder(request, params.payload)
      .withValidationMerchantEventHandler(async (validationRequest) => {
        try {
          const data = await firstValueFrom(
            this._applePayApi.merchantVerification(validationRequest),
          );

          return {
            displayName: data.display_name,
            domainName: data.domain_name,
            epochTimestamp: data.epoch_timestamp,
            expiresAt: data.expires_at,
            merchantIdentifier: data.merchant_identifier,
            merchantSessionIdentifier: data.merchant_session_identifier,
            nonce: data.nonce,
            operationalAnalyticsIdentifier: data.operational_analytics_identifier,
            pspId: data.psp_id,
            retries: data.retries,
            signature: data.signature,
          } as MerchantSession;
        } catch {
          this._toastrService.notify('_SHARED.ERRORS.TECHNICAL_PROBLEM');
          return;
        }
      })
      .withPaymentAuthorizedEventHandler(async (token: string) => {
        this._applePayService.putToken(token);
      })
      .withCancelEventHandler(params.onCancel)
      .build();
  }
}
